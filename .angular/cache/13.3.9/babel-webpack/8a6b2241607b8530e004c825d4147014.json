{"ast":null,"code":"import { root } from '../../util/root';\nimport { Observable } from '../../Observable';\nimport { Subscriber } from '../../Subscriber';\nimport { map } from '../../operators/map';\n\nfunction getCORSRequest() {\n  if (root.XMLHttpRequest) {\n    return new root.XMLHttpRequest();\n  } else if (!!root.XDomainRequest) {\n    return new root.XDomainRequest();\n  } else {\n    throw new Error('CORS is not supported by your browser');\n  }\n}\n\nfunction getXMLHttpRequest() {\n  if (root.XMLHttpRequest) {\n    return new root.XMLHttpRequest();\n  } else {\n    let progId;\n\n    try {\n      const progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n\n      for (let i = 0; i < 3; i++) {\n        try {\n          progId = progIds[i];\n\n          if (new root.ActiveXObject(progId)) {\n            break;\n          }\n        } catch (e) {}\n      }\n\n      return new root.ActiveXObject(progId);\n    } catch (e) {\n      throw new Error('XMLHttpRequest is not supported by your browser');\n    }\n  }\n}\n\nexport function ajaxGet(url, headers = null) {\n  return new AjaxObservable({\n    method: 'GET',\n    url,\n    headers\n  });\n}\nexport function ajaxPost(url, body, headers) {\n  return new AjaxObservable({\n    method: 'POST',\n    url,\n    body,\n    headers\n  });\n}\nexport function ajaxDelete(url, headers) {\n  return new AjaxObservable({\n    method: 'DELETE',\n    url,\n    headers\n  });\n}\nexport function ajaxPut(url, body, headers) {\n  return new AjaxObservable({\n    method: 'PUT',\n    url,\n    body,\n    headers\n  });\n}\nexport function ajaxPatch(url, body, headers) {\n  return new AjaxObservable({\n    method: 'PATCH',\n    url,\n    body,\n    headers\n  });\n}\nconst mapResponse = map((x, index) => x.response);\nexport function ajaxGetJSON(url, headers) {\n  return mapResponse(new AjaxObservable({\n    method: 'GET',\n    url,\n    responseType: 'json',\n    headers\n  }));\n}\nexport class AjaxObservable extends Observable {\n  constructor(urlOrRequest) {\n    super();\n    const request = {\n      async: true,\n      createXHR: function () {\n        return this.crossDomain ? getCORSRequest() : getXMLHttpRequest();\n      },\n      crossDomain: true,\n      withCredentials: false,\n      headers: {},\n      method: 'GET',\n      responseType: 'json',\n      timeout: 0\n    };\n\n    if (typeof urlOrRequest === 'string') {\n      request.url = urlOrRequest;\n    } else {\n      for (const prop in urlOrRequest) {\n        if (urlOrRequest.hasOwnProperty(prop)) {\n          request[prop] = urlOrRequest[prop];\n        }\n      }\n    }\n\n    this.request = request;\n  }\n\n  _subscribe(subscriber) {\n    return new AjaxSubscriber(subscriber, this.request);\n  }\n\n}\n\nAjaxObservable.create = (() => {\n  const create = urlOrRequest => {\n    return new AjaxObservable(urlOrRequest);\n  };\n\n  create.get = ajaxGet;\n  create.post = ajaxPost;\n  create.delete = ajaxDelete;\n  create.put = ajaxPut;\n  create.patch = ajaxPatch;\n  create.getJSON = ajaxGetJSON;\n  return create;\n})();\n\nexport class AjaxSubscriber extends Subscriber {\n  constructor(destination, request) {\n    super(destination);\n    this.request = request;\n    this.done = false;\n    const headers = request.headers = request.headers || {};\n\n    if (!request.crossDomain && !this.getHeader(headers, 'X-Requested-With')) {\n      headers['X-Requested-With'] = 'XMLHttpRequest';\n    }\n\n    let contentTypeHeader = this.getHeader(headers, 'Content-Type');\n\n    if (!contentTypeHeader && !(root.FormData && request.body instanceof root.FormData) && typeof request.body !== 'undefined') {\n      headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n    }\n\n    request.body = this.serializeBody(request.body, this.getHeader(request.headers, 'Content-Type'));\n    this.send();\n  }\n\n  next(e) {\n    this.done = true;\n    const {\n      xhr,\n      request,\n      destination\n    } = this;\n    let result;\n\n    try {\n      result = new AjaxResponse(e, xhr, request);\n    } catch (err) {\n      return destination.error(err);\n    }\n\n    destination.next(result);\n  }\n\n  send() {\n    const {\n      request,\n      request: {\n        user,\n        method,\n        url,\n        async,\n        password,\n        headers,\n        body\n      }\n    } = this;\n\n    try {\n      const xhr = this.xhr = request.createXHR();\n      this.setupEvents(xhr, request);\n\n      if (user) {\n        xhr.open(method, url, async, user, password);\n      } else {\n        xhr.open(method, url, async);\n      }\n\n      if (async) {\n        xhr.timeout = request.timeout;\n        xhr.responseType = request.responseType;\n      }\n\n      if ('withCredentials' in xhr) {\n        xhr.withCredentials = !!request.withCredentials;\n      }\n\n      this.setHeaders(xhr, headers);\n\n      if (body) {\n        xhr.send(body);\n      } else {\n        xhr.send();\n      }\n    } catch (err) {\n      this.error(err);\n    }\n  }\n\n  serializeBody(body, contentType) {\n    if (!body || typeof body === 'string') {\n      return body;\n    } else if (root.FormData && body instanceof root.FormData) {\n      return body;\n    }\n\n    if (contentType) {\n      const splitIndex = contentType.indexOf(';');\n\n      if (splitIndex !== -1) {\n        contentType = contentType.substring(0, splitIndex);\n      }\n    }\n\n    switch (contentType) {\n      case 'application/x-www-form-urlencoded':\n        return Object.keys(body).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(body[key])}`).join('&');\n\n      case 'application/json':\n        return JSON.stringify(body);\n\n      default:\n        return body;\n    }\n  }\n\n  setHeaders(xhr, headers) {\n    for (let key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  }\n\n  getHeader(headers, headerName) {\n    for (let key in headers) {\n      if (key.toLowerCase() === headerName.toLowerCase()) {\n        return headers[key];\n      }\n    }\n\n    return undefined;\n  }\n\n  setupEvents(xhr, request) {\n    const progressSubscriber = request.progressSubscriber;\n\n    function xhrTimeout(e) {\n      const {\n        subscriber,\n        progressSubscriber,\n        request\n      } = xhrTimeout;\n\n      if (progressSubscriber) {\n        progressSubscriber.error(e);\n      }\n\n      let error;\n\n      try {\n        error = new AjaxTimeoutError(this, request);\n      } catch (err) {\n        error = err;\n      }\n\n      subscriber.error(error);\n    }\n\n    xhr.ontimeout = xhrTimeout;\n    xhrTimeout.request = request;\n    xhrTimeout.subscriber = this;\n    xhrTimeout.progressSubscriber = progressSubscriber;\n\n    if (xhr.upload && 'withCredentials' in xhr) {\n      if (progressSubscriber) {\n        let xhrProgress;\n\n        xhrProgress = function (e) {\n          const {\n            progressSubscriber\n          } = xhrProgress;\n          progressSubscriber.next(e);\n        };\n\n        if (root.XDomainRequest) {\n          xhr.onprogress = xhrProgress;\n        } else {\n          xhr.upload.onprogress = xhrProgress;\n        }\n\n        xhrProgress.progressSubscriber = progressSubscriber;\n      }\n\n      let xhrError;\n\n      xhrError = function (e) {\n        const {\n          progressSubscriber,\n          subscriber,\n          request\n        } = xhrError;\n\n        if (progressSubscriber) {\n          progressSubscriber.error(e);\n        }\n\n        let error;\n\n        try {\n          error = new AjaxError('ajax error', this, request);\n        } catch (err) {\n          error = err;\n        }\n\n        subscriber.error(error);\n      };\n\n      xhr.onerror = xhrError;\n      xhrError.request = request;\n      xhrError.subscriber = this;\n      xhrError.progressSubscriber = progressSubscriber;\n    }\n\n    function xhrReadyStateChange(e) {\n      return;\n    }\n\n    xhr.onreadystatechange = xhrReadyStateChange;\n    xhrReadyStateChange.subscriber = this;\n    xhrReadyStateChange.progressSubscriber = progressSubscriber;\n    xhrReadyStateChange.request = request;\n\n    function xhrLoad(e) {\n      const {\n        subscriber,\n        progressSubscriber,\n        request\n      } = xhrLoad;\n\n      if (this.readyState === 4) {\n        let status = this.status === 1223 ? 204 : this.status;\n        let response = this.responseType === 'text' ? this.response || this.responseText : this.response;\n\n        if (status === 0) {\n          status = response ? 200 : 0;\n        }\n\n        if (status < 400) {\n          if (progressSubscriber) {\n            progressSubscriber.complete();\n          }\n\n          subscriber.next(e);\n          subscriber.complete();\n        } else {\n          if (progressSubscriber) {\n            progressSubscriber.error(e);\n          }\n\n          let error;\n\n          try {\n            error = new AjaxError('ajax error ' + status, this, request);\n          } catch (err) {\n            error = err;\n          }\n\n          subscriber.error(error);\n        }\n      }\n    }\n\n    xhr.onload = xhrLoad;\n    xhrLoad.subscriber = this;\n    xhrLoad.progressSubscriber = progressSubscriber;\n    xhrLoad.request = request;\n  }\n\n  unsubscribe() {\n    const {\n      done,\n      xhr\n    } = this;\n\n    if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n      xhr.abort();\n    }\n\n    super.unsubscribe();\n  }\n\n}\nexport class AjaxResponse {\n  constructor(originalEvent, xhr, request) {\n    this.originalEvent = originalEvent;\n    this.xhr = xhr;\n    this.request = request;\n    this.status = xhr.status;\n    this.responseType = xhr.responseType || request.responseType;\n    this.response = parseXhrResponse(this.responseType, xhr);\n  }\n\n}\n\nconst AjaxErrorImpl = (() => {\n  function AjaxErrorImpl(message, xhr, request) {\n    Error.call(this);\n    this.message = message;\n    this.name = 'AjaxError';\n    this.xhr = xhr;\n    this.request = request;\n    this.status = xhr.status;\n    this.responseType = xhr.responseType || request.responseType;\n    this.response = parseXhrResponse(this.responseType, xhr);\n    return this;\n  }\n\n  AjaxErrorImpl.prototype = Object.create(Error.prototype);\n  return AjaxErrorImpl;\n})();\n\nexport const AjaxError = AjaxErrorImpl;\n\nfunction parseJson(xhr) {\n  if ('response' in xhr) {\n    return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n  } else {\n    return JSON.parse(xhr.responseText || 'null');\n  }\n}\n\nfunction parseXhrResponse(responseType, xhr) {\n  switch (responseType) {\n    case 'json':\n      return parseJson(xhr);\n\n    case 'xml':\n      return xhr.responseXML;\n\n    case 'text':\n    default:\n      return 'response' in xhr ? xhr.response : xhr.responseText;\n  }\n}\n\nfunction AjaxTimeoutErrorImpl(xhr, request) {\n  AjaxError.call(this, 'ajax timeout', xhr, request);\n  this.name = 'AjaxTimeoutError';\n  return this;\n}\n\nexport const AjaxTimeoutError = AjaxTimeoutErrorImpl; //# sourceMappingURL=AjaxObservable.js.map","map":null,"metadata":{},"sourceType":"module"}