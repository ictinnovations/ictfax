{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar _layoutHelper = require(\"./layoutHelper\");\n\nvar radialCoordinate = _layoutHelper.radialCoordinate;\n\nvar echarts = require(\"../../echarts\");\n\nvar bbox = require(\"zrender/lib/core/bbox\");\n\nvar View = require(\"../../coord/View\");\n\nvar roamHelper = require(\"../../component/helper/roamHelper\");\n\nvar RoamController = require(\"../../component/helper/RoamController\");\n\nvar _cursorHelper = require(\"../../component/helper/cursorHelper\");\n\nvar onIrrelevantElement = _cursorHelper.onIrrelevantElement;\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar TreeShape = graphic.extendShape({\n  shape: {\n    parentPoint: [],\n    childPoints: [],\n    orient: '',\n    forkPosition: ''\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var childPoints = shape.childPoints;\n    var childLen = childPoints.length;\n    var parentPoint = shape.parentPoint;\n    var firstChildPos = childPoints[0];\n    var lastChildPos = childPoints[childLen - 1];\n\n    if (childLen === 1) {\n      ctx.moveTo(parentPoint[0], parentPoint[1]);\n      ctx.lineTo(firstChildPos[0], firstChildPos[1]);\n      return;\n    }\n\n    var orient = shape.orient;\n    var forkDim = orient === 'TB' || orient === 'BT' ? 0 : 1;\n    var otherDim = 1 - forkDim;\n    var forkPosition = parsePercent(shape.forkPosition, 1);\n    var tmpPoint = [];\n    tmpPoint[forkDim] = parentPoint[forkDim];\n    tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;\n    ctx.moveTo(parentPoint[0], parentPoint[1]);\n    ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    ctx.moveTo(firstChildPos[0], firstChildPos[1]);\n    tmpPoint[forkDim] = firstChildPos[forkDim];\n    ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    tmpPoint[forkDim] = lastChildPos[forkDim];\n    ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    ctx.lineTo(lastChildPos[0], lastChildPos[1]);\n\n    for (var i = 1; i < childLen - 1; i++) {\n      var point = childPoints[i];\n      ctx.moveTo(point[0], point[1]);\n      tmpPoint[forkDim] = point[forkDim];\n      ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n    }\n  }\n});\n\nvar _default = echarts.extendChartView({\n  type: 'tree',\n\n  /**\n   * Init the chart\n   * @override\n   * @param  {module:echarts/model/Global} ecModel\n   * @param  {module:echarts/ExtensionAPI} api\n   */\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {module:echarts/data/Tree}\n     */\n    this._oldTree;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this._mainGroup = new graphic.Group();\n    /**\n     * @private\n     * @type {module:echarts/componet/helper/RoamController}\n     */\n\n    this._controller = new RoamController(api.getZr());\n    this._controllerHost = {\n      target: this.group\n    };\n    this.group.add(this._mainGroup);\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var layoutInfo = seriesModel.layoutInfo;\n    var group = this._mainGroup;\n    var layout = seriesModel.get('layout');\n\n    if (layout === 'radial') {\n      group.attr('position', [layoutInfo.x + layoutInfo.width / 2, layoutInfo.y + layoutInfo.height / 2]);\n    } else {\n      group.attr('position', [layoutInfo.x, layoutInfo.y]);\n    }\n\n    this._updateViewCoordSys(seriesModel, layoutInfo, layout);\n\n    this._updateController(seriesModel, ecModel, api);\n\n    var oldData = this._data;\n    var seriesScope = {\n      expandAndCollapse: seriesModel.get('expandAndCollapse'),\n      layout: layout,\n      edgeShape: seriesModel.get('edgeShape'),\n      edgeForkPosition: seriesModel.get('edgeForkPosition'),\n      orient: seriesModel.getOrient(),\n      curvature: seriesModel.get('lineStyle.curveness'),\n      symbolRotate: seriesModel.get('symbolRotate'),\n      symbolOffset: seriesModel.get('symbolOffset'),\n      hoverAnimation: seriesModel.get('hoverAnimation'),\n      useNameLabel: true,\n      fadeIn: true\n    };\n    data.diff(oldData).add(function (newIdx) {\n      if (symbolNeedsDraw(data, newIdx)) {\n        // Create node and edge\n        updateNode(data, newIdx, null, group, seriesModel, seriesScope);\n      }\n    }).update(function (newIdx, oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\n      if (!symbolNeedsDraw(data, newIdx)) {\n        symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);\n        return;\n      } // Update node and edge\n\n\n      updateNode(data, newIdx, symbolEl, group, seriesModel, seriesScope);\n    }).remove(function (oldIdx) {\n      var symbolEl = oldData.getItemGraphicEl(oldIdx); // When remove a collapsed node of subtree, since the collapsed\n      // node haven't been initialized with a symbol element,\n      // you can't found it's symbol element through index.\n      // so if we want to remove the symbol element we should insure\n      // that the symbol element is not null.\n\n      if (symbolEl) {\n        removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);\n      }\n    }).execute();\n    this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');\n\n    this._updateNodeAndLinkScale(seriesModel);\n\n    if (seriesScope.expandAndCollapse === true) {\n      data.eachItemGraphicEl(function (el, dataIndex) {\n        el.off('click').on('click', function () {\n          api.dispatchAction({\n            type: 'treeExpandAndCollapse',\n            seriesId: seriesModel.id,\n            dataIndex: dataIndex\n          });\n        });\n      });\n    }\n\n    this._data = data;\n  },\n  _updateViewCoordSys: function (seriesModel) {\n    var data = seriesModel.getData();\n    var points = [];\n    data.each(function (idx) {\n      var layout = data.getItemLayout(idx);\n\n      if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {\n        points.push([+layout.x, +layout.y]);\n      }\n    });\n    var min = [];\n    var max = [];\n    bbox.fromPoints(points, min, max); // If don't Store min max when collapse the root node after roam,\n    // the root node will disappear.\n\n    var oldMin = this._min;\n    var oldMax = this._max; // If width or height is 0\n\n    if (max[0] - min[0] === 0) {\n      min[0] = oldMin ? oldMin[0] : min[0] - 1;\n      max[0] = oldMax ? oldMax[0] : max[0] + 1;\n    }\n\n    if (max[1] - min[1] === 0) {\n      min[1] = oldMin ? oldMin[1] : min[1] - 1;\n      max[1] = oldMax ? oldMax[1] : max[1] + 1;\n    }\n\n    var viewCoordSys = seriesModel.coordinateSystem = new View();\n    viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');\n    viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    viewCoordSys.setCenter(seriesModel.get('center'));\n    viewCoordSys.setZoom(seriesModel.get('zoom')); // Here we use viewCoordSys just for computing the 'position' and 'scale' of the group\n\n    this.group.attr({\n      position: viewCoordSys.position,\n      scale: viewCoordSys.scale\n    });\n    this._viewCoordSys = viewCoordSys;\n    this._min = min;\n    this._max = max;\n  },\n  _updateController: function (seriesModel, ecModel, api) {\n    var controller = this._controller;\n    var controllerHost = this._controllerHost;\n    var group = this.group;\n    controller.setPointerChecker(function (e, x, y) {\n      var rect = group.getBoundingRect();\n      rect.applyTransform(group.transform);\n      return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);\n    });\n    controller.enable(seriesModel.get('roam'));\n    controllerHost.zoomLimit = seriesModel.get('scaleLimit');\n    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();\n    controller.off('pan').off('zoom').on('pan', function (e) {\n      roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'treeRoam',\n        dx: e.dx,\n        dy: e.dy\n      });\n    }, this).on('zoom', function (e) {\n      roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'treeRoam',\n        zoom: e.scale,\n        originX: e.originX,\n        originY: e.originY\n      });\n\n      this._updateNodeAndLinkScale(seriesModel);\n    }, this);\n  },\n  _updateNodeAndLinkScale: function (seriesModel) {\n    var data = seriesModel.getData();\n\n    var nodeScale = this._getNodeGlobalScale(seriesModel);\n\n    var invScale = [nodeScale, nodeScale];\n    data.eachItemGraphicEl(function (el, idx) {\n      el.attr('scale', invScale);\n    });\n  },\n  _getNodeGlobalScale: function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys.type !== 'view') {\n      return 1;\n    }\n\n    var nodeScaleRatio = this._nodeScaleRatio;\n    var groupScale = coordSys.scale;\n    var groupZoom = groupScale && groupScale[0] || 1; // Scale node when zoom changes\n\n    var roamZoom = coordSys.getZoom();\n    var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;\n    return nodeScale / groupZoom;\n  },\n  dispose: function () {\n    this._controller && this._controller.dispose();\n    this._controllerHost = {};\n  },\n  remove: function () {\n    this._mainGroup.removeAll();\n\n    this._data = null;\n  }\n});\n\nfunction symbolNeedsDraw(data, dataIndex) {\n  var layout = data.getItemLayout(dataIndex);\n  return layout && !isNaN(layout.x) && !isNaN(layout.y) && data.getItemVisual(dataIndex, 'symbol') !== 'none';\n}\n\nfunction getTreeNodeStyle(node, itemModel, seriesScope) {\n  seriesScope.itemModel = itemModel;\n  seriesScope.itemStyle = itemModel.getModel('itemStyle').getItemStyle();\n  seriesScope.hoverItemStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  seriesScope.lineStyle = itemModel.getModel('lineStyle').getLineStyle();\n  seriesScope.labelModel = itemModel.getModel('label');\n  seriesScope.hoverLabelModel = itemModel.getModel('emphasis.label');\n\n  if (node.isExpand === false && node.children.length !== 0) {\n    seriesScope.symbolInnerColor = seriesScope.itemStyle.fill;\n  } else {\n    seriesScope.symbolInnerColor = '#fff';\n  }\n\n  return seriesScope;\n}\n\nfunction updateNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {\n  var isInit = !symbolEl;\n  var node = data.tree.getNodeByDataIndex(dataIndex);\n  var itemModel = node.getModel();\n  var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);\n  var virtualRoot = data.tree.root;\n  var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);\n  var sourceLayout = source.getLayout();\n  var sourceOldLayout = sourceSymbolEl ? {\n    x: sourceSymbolEl.position[0],\n    y: sourceSymbolEl.position[1],\n    rawX: sourceSymbolEl.__radialOldRawX,\n    rawY: sourceSymbolEl.__radialOldRawY\n  } : sourceLayout;\n  var targetLayout = node.getLayout();\n\n  if (isInit) {\n    symbolEl = new SymbolClz(data, dataIndex, seriesScope);\n    symbolEl.attr('position', [sourceOldLayout.x, sourceOldLayout.y]);\n  } else {\n    symbolEl.updateData(data, dataIndex, seriesScope);\n  }\n\n  symbolEl.__radialOldRawX = symbolEl.__radialRawX;\n  symbolEl.__radialOldRawY = symbolEl.__radialRawY;\n  symbolEl.__radialRawX = targetLayout.rawX;\n  symbolEl.__radialRawY = targetLayout.rawY;\n  group.add(symbolEl);\n  data.setItemGraphicEl(dataIndex, symbolEl);\n  graphic.updateProps(symbolEl, {\n    position: [targetLayout.x, targetLayout.y]\n  }, seriesModel);\n  var symbolPath = symbolEl.getSymbolPath();\n\n  if (seriesScope.layout === 'radial') {\n    var realRoot = virtualRoot.children[0];\n    var rootLayout = realRoot.getLayout();\n    var length = realRoot.children.length;\n    var rad;\n    var isLeft;\n\n    if (targetLayout.x === rootLayout.x && node.isExpand === true) {\n      var center = {};\n      center.x = (realRoot.children[0].getLayout().x + realRoot.children[length - 1].getLayout().x) / 2;\n      center.y = (realRoot.children[0].getLayout().y + realRoot.children[length - 1].getLayout().y) / 2;\n      rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);\n\n      if (rad < 0) {\n        rad = Math.PI * 2 + rad;\n      }\n\n      isLeft = center.x < rootLayout.x;\n\n      if (isLeft) {\n        rad = rad - Math.PI;\n      }\n    } else {\n      rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);\n\n      if (rad < 0) {\n        rad = Math.PI * 2 + rad;\n      }\n\n      if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {\n        isLeft = targetLayout.x < rootLayout.x;\n\n        if (isLeft) {\n          rad = rad - Math.PI;\n        }\n      } else {\n        isLeft = targetLayout.x > rootLayout.x;\n\n        if (!isLeft) {\n          rad = rad - Math.PI;\n        }\n      }\n    }\n\n    var textPosition = isLeft ? 'left' : 'right';\n    var rotate = seriesScope.labelModel.get('rotate');\n    var labelRotateRadian = rotate * (Math.PI / 180);\n    symbolPath.setStyle({\n      textPosition: seriesScope.labelModel.get('position') || textPosition,\n      textRotation: rotate == null ? -rad : labelRotateRadian,\n      textOrigin: 'center',\n      verticalAlign: 'middle'\n    });\n  }\n\n  drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope);\n}\n\nfunction drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope) {\n  var edgeShape = seriesScope.edgeShape;\n  var edge = symbolEl.__edge;\n\n  if (edgeShape === 'curve') {\n    if (node.parentNode && node.parentNode !== virtualRoot) {\n      if (!edge) {\n        edge = symbolEl.__edge = new graphic.BezierCurve({\n          shape: getEdgeShape(seriesScope, sourceOldLayout, sourceOldLayout),\n          style: zrUtil.defaults({\n            opacity: 0,\n            strokeNoScale: true\n          }, seriesScope.lineStyle)\n        });\n      }\n\n      graphic.updateProps(edge, {\n        shape: getEdgeShape(seriesScope, sourceLayout, targetLayout),\n        style: zrUtil.defaults({\n          opacity: 1\n        }, seriesScope.lineStyle)\n      }, seriesModel);\n    }\n  } else if (edgeShape === 'polyline') {\n    if (seriesScope.layout === 'orthogonal') {\n      if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {\n        var children = node.children;\n        var childPoints = [];\n\n        for (var i = 0; i < children.length; i++) {\n          var childLayout = children[i].getLayout();\n          childPoints.push([childLayout.x, childLayout.y]);\n        }\n\n        if (!edge) {\n          edge = symbolEl.__edge = new TreeShape({\n            shape: {\n              parentPoint: [targetLayout.x, targetLayout.y],\n              childPoints: [[targetLayout.x, targetLayout.y]],\n              orient: seriesScope.orient,\n              forkPosition: seriesScope.edgeForkPosition\n            },\n            style: zrUtil.defaults({\n              opacity: 0,\n              strokeNoScale: true\n            }, seriesScope.lineStyle)\n          });\n        }\n\n        graphic.updateProps(edge, {\n          shape: {\n            parentPoint: [targetLayout.x, targetLayout.y],\n            childPoints: childPoints\n          },\n          style: zrUtil.defaults({\n            opacity: 1\n          }, seriesScope.lineStyle)\n        }, seriesModel);\n      }\n    } else {}\n  }\n\n  group.add(edge);\n}\n\nfunction removeNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {\n  var node = data.tree.getNodeByDataIndex(dataIndex);\n  var virtualRoot = data.tree.root;\n  var itemModel = node.getModel();\n  var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);\n  var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n  var edgeShape = seriesScope.edgeShape;\n  var sourceLayout;\n\n  while (sourceLayout = source.getLayout(), sourceLayout == null) {\n    source = source.parentNode === virtualRoot ? source : source.parentNode || source;\n  }\n\n  graphic.updateProps(symbolEl, {\n    position: [sourceLayout.x + 1, sourceLayout.y + 1]\n  }, seriesModel, function () {\n    group.remove(symbolEl);\n    data.setItemGraphicEl(dataIndex, null);\n  });\n  symbolEl.fadeOut(null, {\n    keepLabel: true\n  });\n  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);\n  var sourceEdge = sourceSymbolEl.__edge; // 1. when expand the sub tree, delete the children node should delete the edge of\n  // the source at the same time. because the polyline edge shape is only owned by the source.\n  // 2.when the node is the only children of the source, delete the node should delete the edge of\n  // the source at the same time. the same reason as above.\n\n  var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : undefined);\n  var edgeShape = seriesScope.edgeShape;\n\n  if (edge) {\n    if (edgeShape === 'curve') {\n      graphic.updateProps(edge, {\n        shape: getEdgeShape(seriesScope, sourceLayout, sourceLayout),\n        style: {\n          opacity: 0\n        }\n      }, seriesModel, function () {\n        group.remove(edge);\n      });\n    } else if (edgeShape === 'polyline' && seriesScope.layout === 'orthogonal') {\n      graphic.updateProps(edge, {\n        shape: {\n          parentPoint: [sourceLayout.x, sourceLayout.y],\n          childPoints: [[sourceLayout.x, sourceLayout.y]]\n        },\n        style: {\n          opacity: 0\n        }\n      }, seriesModel, function () {\n        group.remove(edge);\n      });\n    }\n  }\n}\n\nfunction getEdgeShape(seriesScope, sourceLayout, targetLayout) {\n  var cpx1;\n  var cpy1;\n  var cpx2;\n  var cpy2;\n  var orient = seriesScope.orient;\n  var x1;\n  var x2;\n  var y1;\n  var y2;\n\n  if (seriesScope.layout === 'radial') {\n    x1 = sourceLayout.rawX;\n    y1 = sourceLayout.rawY;\n    x2 = targetLayout.rawX;\n    y2 = targetLayout.rawY;\n    var radialCoor1 = radialCoordinate(x1, y1);\n    var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * seriesScope.curvature);\n    var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * seriesScope.curvature);\n    var radialCoor4 = radialCoordinate(x2, y2);\n    return {\n      x1: radialCoor1.x,\n      y1: radialCoor1.y,\n      x2: radialCoor4.x,\n      y2: radialCoor4.y,\n      cpx1: radialCoor2.x,\n      cpy1: radialCoor2.y,\n      cpx2: radialCoor3.x,\n      cpy2: radialCoor3.y\n    };\n  } else {\n    x1 = sourceLayout.x;\n    y1 = sourceLayout.y;\n    x2 = targetLayout.x;\n    y2 = targetLayout.y;\n\n    if (orient === 'LR' || orient === 'RL') {\n      cpx1 = x1 + (x2 - x1) * seriesScope.curvature;\n      cpy1 = y1;\n      cpx2 = x2 + (x1 - x2) * seriesScope.curvature;\n      cpy2 = y2;\n    }\n\n    if (orient === 'TB' || orient === 'BT') {\n      cpx1 = x1;\n      cpy1 = y1 + (y2 - y1) * seriesScope.curvature;\n      cpx2 = x2;\n      cpy2 = y2 + (y1 - y2) * seriesScope.curvature;\n    }\n  }\n\n  return {\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2,\n    cpx1: cpx1,\n    cpy1: cpy1,\n    cpx2: cpx2,\n    cpy2: cpy2\n  };\n}\n\nmodule.exports = _default;","map":null,"metadata":{},"sourceType":"script"}