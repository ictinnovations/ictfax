{"ast":null,"code":"import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n  constructor(assertDeepEqual) {\n    super(VirtualAction, defaultMaxFrame);\n    this.assertDeepEqual = assertDeepEqual;\n    this.hotObservables = [];\n    this.coldObservables = [];\n    this.flushTests = [];\n    this.runMode = false;\n  }\n\n  createTime(marbles) {\n    const indexOf = marbles.indexOf('|');\n\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n\n    return indexOf * TestScheduler.frameTimeFactor;\n  }\n\n  createColdObservable(marbles, values, error) {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const cold = new ColdObservable(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  }\n\n  createHotObservable(marbles, values, error) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const subject = new HotObservable(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  }\n\n  materializeInnerObservable(observable, outerFrame) {\n    const messages = [];\n    observable.subscribe(value => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createNext(value)\n      });\n    }, err => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createError(err)\n      });\n    }, () => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createComplete()\n      });\n    });\n    return messages;\n  }\n\n  expectObservable(observable, subscriptionMarbles = null) {\n    const actual = [];\n    const flushTest = {\n      actual,\n      ready: false\n    };\n    const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n    const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ? 0 : subscriptionParsed.subscribedFrame;\n    const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n    let subscription;\n    this.schedule(() => {\n      subscription = observable.subscribe(x => {\n        let value = x;\n\n        if (x instanceof Observable) {\n          value = this.materializeInnerObservable(value, this.frame);\n        }\n\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createNext(value)\n        });\n      }, err => {\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createError(err)\n        });\n      }, () => {\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createComplete()\n        });\n      });\n    }, subscriptionFrame);\n\n    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n      this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n    }\n\n    this.flushTests.push(flushTest);\n    const {\n      runMode\n    } = this;\n    return {\n      toBe(marbles, values, errorValue) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n      }\n\n    };\n  }\n\n  expectSubscriptions(actualSubscriptionLogs) {\n    const flushTest = {\n      actual: actualSubscriptionLogs,\n      ready: false\n    };\n    this.flushTests.push(flushTest);\n    const {\n      runMode\n    } = this;\n    return {\n      toBe(marbles) {\n        const marblesArray = typeof marbles === 'string' ? [marbles] : marbles;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));\n      }\n\n    };\n  }\n\n  flush() {\n    const hotObservables = this.hotObservables;\n\n    while (hotObservables.length > 0) {\n      hotObservables.shift().setup();\n    }\n\n    super.flush();\n    this.flushTests = this.flushTests.filter(test => {\n      if (test.ready) {\n        this.assertDeepEqual(test.actual, test.expected);\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  static parseMarblesAsSubscriptions(marbles, runMode = false) {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog(Number.POSITIVE_INFINITY);\n    }\n\n    const len = marbles.length;\n    let groupStart = -1;\n    let subscriptionFrame = Number.POSITIVE_INFINITY;\n    let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n    let frame = 0;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n\n      const advanceFrameBy = count => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n\n      const c = marbles[i];\n\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n\n          break;\n\n        case '-':\n          advanceFrameBy(1);\n          break;\n\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n\n        case '^':\n          if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          advanceFrameBy(1);\n          break;\n\n        case '!':\n          if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || marbles[i - 1] === ' ') {\n              const buffer = marbles.slice(i);\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' + 'subscription marble diagram. Found instead \\'' + c + '\\'.');\n      }\n\n      frame = nextFrame;\n    }\n\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  }\n\n  static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n\n    const len = marbles.length;\n    const testMessages = [];\n    const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n    let frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    const getValue = typeof values !== 'object' ? x => x : x => {\n      if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n        return values[x].messages;\n      }\n\n      return values[x];\n    };\n    let groupStart = -1;\n\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n\n      const advanceFrameBy = count => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n\n      let notification;\n      const c = marbles[i];\n\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n\n          break;\n\n        case '-':\n          advanceFrameBy(1);\n          break;\n\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n\n        case '|':\n          notification = Notification.createComplete();\n          advanceFrameBy(1);\n          break;\n\n        case '^':\n          advanceFrameBy(1);\n          break;\n\n        case '#':\n          notification = Notification.createError(errorValue || 'error');\n          advanceFrameBy(1);\n          break;\n\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || marbles[i - 1] === ' ') {\n              const buffer = marbles.slice(i);\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs;\n\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n\n                  default:\n                    break;\n                }\n\n                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n\n          notification = Notification.createNext(getValue(c));\n          advanceFrameBy(1);\n          break;\n      }\n\n      if (notification) {\n        testMessages.push({\n          frame: groupStart > -1 ? groupStart : frame,\n          notification\n        });\n      }\n\n      frame = nextFrame;\n    }\n\n    return testMessages;\n  }\n\n  run(callback) {\n    const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n    const prevMaxFrames = this.maxFrames;\n    TestScheduler.frameTimeFactor = 1;\n    this.maxFrames = Number.POSITIVE_INFINITY;\n    this.runMode = true;\n    AsyncScheduler.delegate = this;\n    const helpers = {\n      cold: this.createColdObservable.bind(this),\n      hot: this.createHotObservable.bind(this),\n      flush: this.flush.bind(this),\n      expectObservable: this.expectObservable.bind(this),\n      expectSubscriptions: this.expectSubscriptions.bind(this)\n    };\n\n    try {\n      const ret = callback(helpers);\n      this.flush();\n      return ret;\n    } finally {\n      TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n      this.maxFrames = prevMaxFrames;\n      this.runMode = false;\n      AsyncScheduler.delegate = undefined;\n    }\n  }\n\n} //# sourceMappingURL=TestScheduler.js.map","map":null,"metadata":{},"sourceType":"module"}