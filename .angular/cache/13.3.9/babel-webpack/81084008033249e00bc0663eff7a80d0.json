{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar map = _util.map;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\n\nvar _task = require(\"./task\");\n\nvar createTask = _task.createTask;\n\nvar _component = require(\"../util/component\");\n\nvar getUID = _component.getUID;\n\nvar GlobalModel = require(\"../model/Global\");\n\nvar ExtensionAPI = require(\"../ExtensionAPI\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\n\nfunction Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished; // Fix current processors in case that in some rear cases that\n  // processors might be registered after echarts instance created.\n  // Register processors incrementally for a echarts instance is\n  // not supported by this stream architecture.\n\n  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n  var visualHandlers = this._visualHandlers = visualHandlers.slice();\n  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\n\nvar proto = Scheduler.prototype;\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} payload\n */\n\nproto.restoreData = function (ecModel, payload) {\n  // TODO: Only restore needed series and components, but not all components.\n  // Currently `restoreData` of all of the series and component will be called.\n  // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n  // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n  // and some components like coordinate system, axes, dataZoom, visualMap only\n  // need their target series refresh.\n  // (1) If we are implementing this feature some day, we should consider these cases:\n  // if a data processor depends on a component (e.g., dataZoomProcessor depends\n  // on the settings of `dataZoom`), it should be re-performed if the component\n  // is modified by `setOption`.\n  // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n  // it should be re-performed when the result array of `getTargetSeries` changed.\n  // We use `dependencies` to cover these issues.\n  // (3) How to update target series when coordinate system related components modified.\n  // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n  // and this case all of the tasks will be set as dirty.\n  ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n  // depends on all of the series.\n  // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n  // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n  // that the overall task is set as dirty and to be performed, otherwise it probably cause\n  // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n  // probably cause state chaos (consider `dataZoomProcessor`).\n\n  this._stageTaskMap.each(function (taskRecord) {\n    var overallTask = taskRecord.overallTask;\n    overallTask && overallTask.dirty();\n  });\n}; // If seriesModel provided, incremental threshold is check by series data.\n\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n  var step = incremental ? pipeline.step : null;\n  var modDataCount = pCtx && pCtx.modDataCount;\n  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n  return {\n    step: step,\n    modBy: modBy,\n    modDataCount: modDataCount\n  };\n};\n\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n  var data = seriesModel.getData();\n  var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n  // animation frame. Note that some types of series do not provide\n  // `view.incrementalPrepareRender` but support `chart.appendData`. We\n  // use the term `incremental` but not `progressive` to describe the\n  // case that `chart.appendData`.\n\n  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n  // see `test/candlestick-large3.html`\n\n  var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n  seriesModel.pipelineContext = pipeline.context = {\n    progressiveRender: progressiveRender,\n    modDataCount: modDataCount,\n    large: large\n  };\n};\n\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      blockIndex: -1,\n      step: Math.round(progressive || 700),\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\n\nproto.prepareStageTasks = function () {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(this._allHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\n\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\n\nproto.performDataProcessorTasks = function (ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\n\nproto.performVisualTasks = function (ecModel, payload, opt) {\n  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);\n};\n\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n\n        var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n        // if intending to decalare `performRawSeries` in handlers, only\n        // stream-independent (specifically, data item independent) operations can be\n        // performed. Because is a series is filtered, most of the tasks will not\n        // be performed. A stream-dependent operation probably cause wrong biz logic.\n        // Perhaps we should not provide a separate callback for this case instead\n        // of providing the config `performRawSeries`. The stream-dependent operaions\n        // and stream-independent operations should better not be mixed.\n\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n\n  scheduler.unfinished |= unfinished;\n}\n\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\n\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n\n    do {\n      if (task.__block) {\n        pipeline.blockIndex = task.__idxInPipeline;\n        break;\n      }\n\n      task = task.getUpstream();\n    } while (task);\n  });\n};\n\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\n\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n    overallProgress = false;\n    each(ecModel.getSeries(), createStub);\n  }\n\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId);\n\n    if (!stub) {\n      stub = agentStubMap.set(pipelineId, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n    }\n\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      modifyOutputEnd: modifyOutputEnd\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\n\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;","map":{"version":3,"sources":["D:/angular_update/ictfax/node_modules/echarts/lib/stream/Scheduler.js"],"names":["_util","require","each","map","isFunction","createHashMap","noop","_task","createTask","_component","getUID","GlobalModel","ExtensionAPI","_model","normalizeToArray","Scheduler","ecInstance","api","dataProcessorHandlers","visualHandlers","unfinished","_dataProcessorHandlers","slice","_visualHandlers","_allHandlers","concat","_stageTaskMap","proto","prototype","restoreData","ecModel","payload","taskRecord","overallTask","dirty","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","incremental","progressiveEnabled","progressiveRender","__idxInPipeline","blockIndex","step","modDataCount","modBy","Math","ceil","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","data","getData","dataLen","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","round","pipe","dataTask","prepareStageTasks","stageTaskMap","getModel","handler","record","reset","createSeriesStageTask","overallReset","createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","performStageTasks","block","performVisualTasks","opt","stageHandlers","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallNeedDirty","agentStubMap","stub","needSetDirty","updatePayload","performArgs","perform","skip","performRawSeries","isSeriesFiltered","setDirty","dirtyMap","performSeriesTasks","plan","getUpstream","seriesType","getTargetSeries","createOnAllSeries","eachRawSeries","create","eachRawSeriesByType","seriesTaskPlan","seriesTaskReset","seriesTaskCount","useClearVisual","isVisual","isLayout","dispose","removeKey","overallTaskReset","overallProgress","modifyOutputEnd","createStub","getSeries","stubReset","onDirty","stubOnDirty","agent","upstreamContext","stubProgress","getDownstream","clearAllVisual","resetDefines","length","v","makeSeriesTaskProgress","singleSeriesTaskProgress","resetDefineIdx","params","resetDefine","dataEach","i","start","end","progress","wrapStageHandler","detectSeriseType","legacyFunc","ecModelMock","apiMock","e","mockMethods","eachSeriesByType","type","eachComponent","cond","mainType","subType","target","Clz","name","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar map = _util.map;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\n\nvar _task = require(\"./task\");\n\nvar createTask = _task.createTask;\n\nvar _component = require(\"../util/component\");\n\nvar getUID = _component.getUID;\n\nvar GlobalModel = require(\"../model/Global\");\n\nvar ExtensionAPI = require(\"../ExtensionAPI\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\nfunction Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished; // Fix current processors in case that in some rear cases that\n  // processors might be registered after echarts instance created.\n  // Register processors incrementally for a echarts instance is\n  // not supported by this stream architecture.\n\n  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n  var visualHandlers = this._visualHandlers = visualHandlers.slice();\n  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\n\nvar proto = Scheduler.prototype;\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} payload\n */\n\nproto.restoreData = function (ecModel, payload) {\n  // TODO: Only restore needed series and components, but not all components.\n  // Currently `restoreData` of all of the series and component will be called.\n  // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n  // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n  // and some components like coordinate system, axes, dataZoom, visualMap only\n  // need their target series refresh.\n  // (1) If we are implementing this feature some day, we should consider these cases:\n  // if a data processor depends on a component (e.g., dataZoomProcessor depends\n  // on the settings of `dataZoom`), it should be re-performed if the component\n  // is modified by `setOption`.\n  // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n  // it should be re-performed when the result array of `getTargetSeries` changed.\n  // We use `dependencies` to cover these issues.\n  // (3) How to update target series when coordinate system related components modified.\n  // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n  // and this case all of the tasks will be set as dirty.\n  ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n  // depends on all of the series.\n  // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n  // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n  // that the overall task is set as dirty and to be performed, otherwise it probably cause\n  // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n  // probably cause state chaos (consider `dataZoomProcessor`).\n\n  this._stageTaskMap.each(function (taskRecord) {\n    var overallTask = taskRecord.overallTask;\n    overallTask && overallTask.dirty();\n  });\n}; // If seriesModel provided, incremental threshold is check by series data.\n\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n  var step = incremental ? pipeline.step : null;\n  var modDataCount = pCtx && pCtx.modDataCount;\n  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n  return {\n    step: step,\n    modBy: modBy,\n    modDataCount: modDataCount\n  };\n};\n\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n  var data = seriesModel.getData();\n  var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n  // animation frame. Note that some types of series do not provide\n  // `view.incrementalPrepareRender` but support `chart.appendData`. We\n  // use the term `incremental` but not `progressive` to describe the\n  // case that `chart.appendData`.\n\n  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n  // see `test/candlestick-large3.html`\n\n  var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n  seriesModel.pipelineContext = pipeline.context = {\n    progressiveRender: progressiveRender,\n    modDataCount: modDataCount,\n    large: large\n  };\n};\n\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      blockIndex: -1,\n      step: Math.round(progressive || 700),\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\n\nproto.prepareStageTasks = function () {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(this._allHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\n\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\n\nproto.performDataProcessorTasks = function (ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\n\nproto.performVisualTasks = function (ecModel, payload, opt) {\n  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);\n};\n\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n\n        var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n        // if intending to decalare `performRawSeries` in handlers, only\n        // stream-independent (specifically, data item independent) operations can be\n        // performed. Because is a series is filtered, most of the tasks will not\n        // be performed. A stream-dependent operation probably cause wrong biz logic.\n        // Perhaps we should not provide a separate callback for this case instead\n        // of providing the config `performRawSeries`. The stream-dependent operaions\n        // and stream-independent operations should better not be mixed.\n\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n\n  scheduler.unfinished |= unfinished;\n}\n\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\n\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n\n    do {\n      if (task.__block) {\n        pipeline.blockIndex = task.__idxInPipeline;\n        break;\n      }\n\n      task = task.getUpstream();\n    } while (task);\n  });\n};\n\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\n\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n      overallProgress = false;\n      each(ecModel.getSeries(), createStub);\n    }\n\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId);\n\n    if (!stub) {\n      stub = agentStubMap.set(pipelineId, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n    }\n\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      modifyOutputEnd: modifyOutputEnd\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\n\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}