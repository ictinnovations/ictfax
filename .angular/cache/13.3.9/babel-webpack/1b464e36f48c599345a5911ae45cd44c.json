{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar KEY_DELIMITER = '-->';\n/**\n * params handler\n * @param {module:echarts/model/SeriesModel} seriesModel\n * @returns {*}\n */\n\nvar getAutoCurvenessParams = function (seriesModel) {\n  return seriesModel.get('autoCurveness') || null;\n};\n/**\n * Generate a list of edge curvatures, 20 is the default\n * @param {module:echarts/model/SeriesModel} seriesModel\n * @param {number} appendLength\n * @return  20 => [0, -0.2, 0.2, -0.4, 0.4, -0.6, 0.6, -0.8, 0.8, -1, 1, -1.2, 1.2, -1.4, 1.4, -1.6, 1.6, -1.8, 1.8, -2]\n */\n\n\nvar createCurveness = function (seriesModel, appendLength) {\n  var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);\n  var length = 20;\n  var curvenessList = []; // handler the function set\n\n  if (typeof autoCurvenessParmas === 'number') {\n    length = autoCurvenessParmas;\n  } else if (zrUtil.isArray(autoCurvenessParmas)) {\n    seriesModel.__curvenessList = autoCurvenessParmas;\n    return;\n  } // append length\n\n\n  if (appendLength > length) {\n    length = appendLength;\n  } // make sure the length is even\n\n\n  var len = length % 2 ? length + 2 : length + 3;\n  curvenessList = [];\n\n  for (var i = 0; i < len; i++) {\n    curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));\n  }\n\n  seriesModel.__curvenessList = curvenessList;\n};\n/**\n * Create different cache key data in the positive and negative directions, in order to set the curvature later\n * @param {number|string|module:echarts/data/Graph.Node} n1\n * @param {number|string|module:echarts/data/Graph.Node} n2\n * @param {module:echarts/model/SeriesModel} seriesModel\n * @returns {string} key\n */\n\n\nvar getKeyOfEdges = function (n1, n2, seriesModel) {\n  var source = [n1.id, n1.dataIndex].join('.');\n  var target = [n2.id, n2.dataIndex].join('.');\n  return [seriesModel.uid, source, target].join(KEY_DELIMITER);\n};\n/**\n * get opposite key\n * @param {string} key\n * @returns {string}\n */\n\n\nvar getOppositeKey = function (key) {\n  var keys = key.split(KEY_DELIMITER);\n  return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);\n};\n/**\n * get edgeMap with key\n * @param edge\n * @param {module:echarts/model/SeriesModel} seriesModel\n */\n\n\nvar getEdgeFromMap = function (edge, seriesModel) {\n  var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);\n  return seriesModel.__edgeMap[key];\n};\n/**\n * calculate all cases total length\n * @param edge\n * @param seriesModel\n * @returns {number}\n */\n\n\nvar getTotalLengthBetweenNodes = function (edge, seriesModel) {\n  var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);\n  var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);\n  return len + lenV;\n};\n/**\n *\n * @param key\n */\n\n\nvar getEdgeMapLengthWithKey = function (key, seriesModel) {\n  var edgeMap = seriesModel.__edgeMap;\n  return edgeMap[key] ? edgeMap[key].length : 0;\n};\n/**\n * Count the number of edges between the same two points, used to obtain the curvature table and the parity of the edge\n * @see /graph/GraphSeries.js@getInitialData\n * @param {module:echarts/model/SeriesModel} seriesModel\n */\n\n\nfunction initCurvenessList(seriesModel) {\n  if (!getAutoCurvenessParams(seriesModel)) {\n    return;\n  }\n\n  seriesModel.__curvenessList = [];\n  seriesModel.__edgeMap = {}; // calc the array of curveness List\n\n  createCurveness(seriesModel);\n}\n/**\n * set edgeMap with key\n * @param {number|string|module:echarts/data/Graph.Node} n1\n * @param {number|string|module:echarts/data/Graph.Node} n2\n * @param {module:echarts/model/SeriesModel} seriesModel\n * @param {number} index\n */\n\n\nfunction createEdgeMapForCurveness(n1, n2, seriesModel, index) {\n  if (!getAutoCurvenessParams(seriesModel)) {\n    return;\n  }\n\n  var key = getKeyOfEdges(n1, n2, seriesModel);\n  var edgeMap = seriesModel.__edgeMap;\n  var oppositeEdges = edgeMap[getOppositeKey(key)]; // set direction\n\n  if (edgeMap[key] && !oppositeEdges) {\n    edgeMap[key].isForward = true;\n  } else if (oppositeEdges && edgeMap[key]) {\n    oppositeEdges.isForward = true;\n    edgeMap[key].isForward = false;\n  }\n\n  edgeMap[key] = edgeMap[key] || [];\n  edgeMap[key].push(index);\n}\n/**\n * get curvature for edge\n * @param edge\n * @param {module:echarts/model/SeriesModel} seriesModel\n * @param index\n */\n\n\nfunction getCurvenessForEdge(edge, seriesModel, index, needReverse) {\n  var autoCurvenessParams = getAutoCurvenessParams(seriesModel);\n  var isArrayParam = zrUtil.isArray(autoCurvenessParams);\n\n  if (!autoCurvenessParams) {\n    return null;\n  }\n\n  var edgeArray = getEdgeFromMap(edge, seriesModel);\n\n  if (!edgeArray) {\n    return null;\n  }\n\n  var edgeIndex = -1;\n\n  for (var i = 0; i < edgeArray.length; i++) {\n    if (edgeArray[i] === index) {\n      edgeIndex = i;\n      break;\n    }\n  } // if totalLen is Longer createCurveness\n\n\n  var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);\n  createCurveness(seriesModel, totalLen);\n  edge.lineStyle = edge.lineStyle || {}; // if is opposite edge, must set curvenss to opposite number\n\n  var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);\n  var curvenessList = seriesModel.__curvenessList; // if pass array no need parity\n\n  var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;\n\n  if (!edgeArray.isForward) {\n    // the opposite edge show outside\n    var oppositeKey = getOppositeKey(curKey);\n    var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);\n    var resValue = curvenessList[edgeIndex + len + parityCorrection]; // isNeedReverse, simple, force type need reverse the curveness in the junction of the forword and the opposite\n\n    if (needReverse) {\n      // set as array may make the parity handle with the len of opposite\n      if (isArrayParam) {\n        if (autoCurvenessParams && autoCurvenessParams[0] === 0) {\n          return (len + parityCorrection) % 2 ? resValue : -resValue;\n        } else {\n          return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;\n        }\n      } else {\n        return (len + parityCorrection) % 2 ? resValue : -resValue;\n      }\n    } else {\n      return curvenessList[edgeIndex + len + parityCorrection];\n    }\n  } else {\n    return curvenessList[parityCorrection + edgeIndex];\n  }\n}\n\nexports.initCurvenessList = initCurvenessList;\nexports.createEdgeMapForCurveness = createEdgeMapForCurveness;\nexports.getCurvenessForEdge = getCurvenessForEdge;","map":null,"metadata":{},"sourceType":"script"}