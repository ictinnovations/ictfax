{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar NodeHighlightPolicy = {\n  NONE: 'none',\n  // not downplay others\n  DESCENDANT: 'descendant',\n  ANCESTOR: 'ancestor',\n  SELF: 'self'\n};\nvar DEFAULT_SECTOR_Z = 2;\nvar DEFAULT_TEXT_Z = 4;\n/**\n * Sunburstce of Sunburst including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\nfunction SunburstPiece(node, seriesModel, ecModel) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: DEFAULT_SECTOR_Z\n  });\n  sector.seriesIndex = seriesModel.seriesIndex;\n  var text = new graphic.Text({\n    z2: DEFAULT_TEXT_Z,\n    silent: node.getModel('label').get('silent')\n  });\n  this.add(sector);\n  this.add(text);\n  this.updateData(true, node, 'normal', seriesModel, ecModel); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar SunburstPieceProto = SunburstPiece.prototype;\n\nSunburstPieceProto.updateData = function (firstCreate, node, state, seriesModel, ecModel) {\n  this.node = node;\n  node.piece = this;\n  seriesModel = seriesModel || this._seriesModel;\n  ecModel = ecModel || this._ecModel;\n  var sector = this.childAt(0);\n  sector.dataIndex = node.dataIndex;\n  var itemModel = node.getModel();\n  var layout = node.getLayout(); // if (!layout) {\n  //     console.log(node.getLayout());\n  // }\n\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n  var visualColor = getNodeColor(node, seriesModel, ecModel);\n  fillDefaultColor(node, seriesModel, visualColor);\n  var normalStyle = itemModel.getModel('itemStyle').getItemStyle();\n  var style;\n\n  if (state === 'normal') {\n    style = normalStyle;\n  } else {\n    var stateStyle = itemModel.getModel(state + '.itemStyle').getItemStyle();\n    style = zrUtil.merge(stateStyle, normalStyle);\n  }\n\n  style = zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: style.fill || visualColor\n  }, style);\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    sector.shape.r = layout.r0;\n    graphic.updateProps(sector, {\n      shape: {\n        r: layout.r\n      }\n    }, seriesModel, node.dataIndex);\n    sector.useStyle(style);\n  } else if (typeof style.fill === 'object' && style.fill.type || typeof sector.style.fill === 'object' && sector.style.fill.type) {\n    // Disable animation for gradient since no interpolation method\n    // is supported for gradient\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel);\n    sector.useStyle(style);\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape,\n      style: style\n    }, seriesModel);\n  }\n\n  this._updateLabel(seriesModel, visualColor, state);\n\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle);\n\n  if (firstCreate) {\n    var highlightPolicy = seriesModel.getShallow('highlightPolicy');\n\n    this._initEvents(sector, node, seriesModel, highlightPolicy);\n  }\n\n  this._seriesModel = seriesModel || this._seriesModel;\n  this._ecModel = ecModel || this._ecModel;\n  graphic.setHoverStyle(this);\n};\n\nSunburstPieceProto.onEmphasis = function (highlightPolicy) {\n  var that = this;\n  this.node.hostTree.root.eachNode(function (n) {\n    if (n.piece) {\n      if (that.node === n) {\n        n.piece.updateData(false, n, 'emphasis');\n      } else if (isNodeHighlighted(n, that.node, highlightPolicy)) {\n        n.piece.childAt(0).trigger('highlight');\n      } else if (highlightPolicy !== NodeHighlightPolicy.NONE) {\n        n.piece.childAt(0).trigger('downplay');\n      }\n    }\n  });\n};\n\nSunburstPieceProto.onNormal = function () {\n  this.node.hostTree.root.eachNode(function (n) {\n    if (n.piece) {\n      n.piece.updateData(false, n, 'normal');\n    }\n  });\n};\n\nSunburstPieceProto.onHighlight = function () {\n  this.updateData(false, this.node, 'highlight');\n};\n\nSunburstPieceProto.onDownplay = function () {\n  this.updateData(false, this.node, 'downplay');\n};\n\nSunburstPieceProto._updateLabel = function (seriesModel, visualColor, state) {\n  var itemModel = this.node.getModel();\n  var normalModel = itemModel.getModel('label');\n  var labelModel = state === 'normal' || state === 'emphasis' ? normalModel : itemModel.getModel(state + '.label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelFormatter = labelModel.get('formatter'); // Use normal formatter if no state formatter is defined\n\n  var labelState = labelFormatter ? state : 'normal';\n  var text = zrUtil.retrieve(seriesModel.getFormattedLabel(this.node.dataIndex, labelState, null, null, 'label'), this.node.name);\n\n  if (getLabelAttr('show') === false) {\n    text = '';\n  }\n\n  var layout = this.node.getLayout();\n  var labelMinAngle = labelModel.get('minAngle');\n\n  if (labelMinAngle == null) {\n    labelMinAngle = normalModel.get('minAngle');\n  }\n\n  labelMinAngle = labelMinAngle / 180 * Math.PI;\n  var angle = layout.endAngle - layout.startAngle;\n\n  if (labelMinAngle != null && Math.abs(angle) < labelMinAngle) {\n    // Not displaying text when angle is too small\n    text = '';\n  }\n\n  var label = this.childAt(1);\n  graphic.setLabelStyle(label.style, label.hoverStyle || {}, normalModel, labelHoverModel, {\n    defaultText: labelModel.getShallow('show') ? text : null,\n    autoColor: visualColor,\n    useInsideStyle: true\n  });\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var r;\n  var labelPosition = getLabelAttr('position');\n  var labelPadding = getLabelAttr('distance') || 0;\n  var textAlign = getLabelAttr('align');\n\n  if (labelPosition === 'outside') {\n    r = layout.r + labelPadding;\n    textAlign = midAngle > Math.PI / 2 ? 'right' : 'left';\n  } else {\n    if (!textAlign || textAlign === 'center') {\n      r = (layout.r + layout.r0) / 2;\n      textAlign = 'center';\n    } else if (textAlign === 'left') {\n      r = layout.r0 + labelPadding;\n\n      if (midAngle > Math.PI / 2) {\n        textAlign = 'right';\n      }\n    } else if (textAlign === 'right') {\n      r = layout.r - labelPadding;\n\n      if (midAngle > Math.PI / 2) {\n        textAlign = 'left';\n      }\n    }\n  }\n\n  label.attr('style', {\n    text: text,\n    textAlign: textAlign,\n    textVerticalAlign: getLabelAttr('verticalAlign') || 'middle',\n    opacity: getLabelAttr('opacity')\n  });\n  var textX = r * dx + layout.cx;\n  var textY = r * dy + layout.cy;\n  label.attr('position', [textX, textY]);\n  var rotateType = getLabelAttr('rotate');\n  var rotate = 0;\n\n  if (rotateType === 'radial') {\n    rotate = -midAngle;\n\n    if (rotate < -Math.PI / 2) {\n      rotate += Math.PI;\n    }\n  } else if (rotateType === 'tangential') {\n    rotate = Math.PI / 2 - midAngle;\n\n    if (rotate > Math.PI / 2) {\n      rotate -= Math.PI;\n    } else if (rotate < -Math.PI / 2) {\n      rotate += Math.PI;\n    }\n  } else if (typeof rotateType === 'number') {\n    rotate = rotateType * Math.PI / 180;\n  }\n\n  label.attr('rotation', rotate);\n\n  function getLabelAttr(name) {\n    var stateAttr = labelModel.get(name);\n\n    if (stateAttr == null) {\n      return normalModel.get(name);\n    } else {\n      return stateAttr;\n    }\n  }\n};\n\nSunburstPieceProto._initEvents = function (sector, node, seriesModel, highlightPolicy) {\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  var that = this;\n\n  var onEmphasis = function () {\n    that.onEmphasis(highlightPolicy);\n  };\n\n  var onNormal = function () {\n    that.onNormal();\n  };\n\n  var onDownplay = function () {\n    that.onDownplay();\n  };\n\n  var onHighlight = function () {\n    that.onHighlight();\n  };\n\n  if (seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal).on('downplay', onDownplay).on('highlight', onHighlight);\n  }\n};\n\nzrUtil.inherits(SunburstPiece, graphic.Group);\nvar _default = SunburstPiece;\n/**\n * Get node color\n *\n * @param {TreeNode} node the node to get color\n * @param {module:echarts/model/Series} seriesModel series\n * @param {module:echarts/model/Global} ecModel echarts defaults\n */\n\nfunction getNodeColor(node, seriesModel, ecModel) {\n  // Color from visualMap\n  var visualColor = node.getVisual('color');\n  var visualMetaList = node.getVisual('visualMeta');\n\n  if (!visualMetaList || visualMetaList.length === 0) {\n    // Use first-generation color if has no visualMap\n    visualColor = null;\n  } // Self color or level color\n\n\n  var color = node.getModel('itemStyle').get('color');\n\n  if (color) {\n    return color;\n  } else if (visualColor) {\n    // Color mapping\n    return visualColor;\n  } else if (node.depth === 0) {\n    // Virtual root node\n    return ecModel.option.color[0];\n  } else {\n    // First-generation color\n    var length = ecModel.option.color.length;\n    color = ecModel.option.color[getRootId(node) % length];\n  }\n\n  return color;\n}\n/**\n * Get index of root in sorted order\n *\n * @param {TreeNode} node current node\n * @return {number} index in root\n */\n\n\nfunction getRootId(node) {\n  var ancestor = node;\n\n  while (ancestor.depth > 1) {\n    ancestor = ancestor.parentNode;\n  }\n\n  var virtualRoot = node.getAncestors()[0];\n  return zrUtil.indexOf(virtualRoot.children, ancestor);\n}\n\nfunction isNodeHighlighted(node, activeNode, policy) {\n  if (policy === NodeHighlightPolicy.NONE) {\n    return false;\n  } else if (policy === NodeHighlightPolicy.SELF) {\n    return node === activeNode;\n  } else if (policy === NodeHighlightPolicy.ANCESTOR) {\n    return node === activeNode || node.isAncestorOf(activeNode);\n  } else {\n    return node === activeNode || node.isDescendantOf(activeNode);\n  }\n} // Fix tooltip callback function params.color incorrect when pick a default color\n\n\nfunction fillDefaultColor(node, seriesModel, color) {\n  var data = seriesModel.getData();\n  data.setItemVisual(node.dataIndex, 'color', color);\n}\n\nmodule.exports = _default;","map":null,"metadata":{},"sourceType":"script"}